// ==================== 快速排序（Quick Sort）====================

/**
 * 快速排序算法原理讲解：
 * 
 * 【核心思想】
 * 快速排序就像"分而治之"的策略：
 * 1. 从数组中选一个数作为"基准"（pivot）
 * 2. 把比基准小的数都放左边，比基准大的数都放右边
 * 3. 对左边和右边分别重复这个过程
 * 4. 最后所有数就排好序了
 * 
 * 【生活中的例子】
 * 想象你要整理一堆书：
 * - 随便拿一本书作为"标准"
 * - 把比这本书薄的放左边，比它厚的放右边
 * - 然后对左边和右边的书堆重复这个过程
 * - 最后所有书就按厚度排好了
 * 
 * 【为什么叫"快速"排序】
 * 因为每次分组后，基准元素就到了它最终应该在的位置，
 * 不需要再移动了。通过不断分组，所有元素都能快速找到自己的位置。
 */

/**
 * 快速排序 - 基础实现（最容易理解的版本）
 * 
 * 算法步骤：
 * 1. 选择一个基准元素（pivot）
 * 2. 将数组分为两部分：小于等于基准的放左边，大于基准的放右边
 * 3. 递归地对左右两部分进行快速排序
 * 4. 合并结果：左边 + 基准 + 右边
 * 
 * @param {number[]} arr - 需要排序的数组
 * @returns {number[]} 返回排序后的新数组
 * 
 * @example
 * quickSort([4, 3, 5, 2, 1, 6]) // [1, 2, 3, 4, 5, 6]
 */
function quickSort(arr) {
  // 【步骤1】递归终止条件：如果数组只有 0 个或 1 个元素，已经是有序的，直接返回
  if (arr.length <= 1) return arr;
  
  // 【步骤2】选择基准元素（pivot）
  // 这里选择中间位置的元素作为基准
  // >> 1 是右移一位，相当于除以 2 并向下取整，例如：5 >> 1 = 2
  const pivotIndex = arr.length >> 1;
  // splice(pivotIndex, 1) 会从数组中删除这个元素，并返回包含它的数组
  // [0] 取出数组中的第一个元素，就是我们的基准
  const pivot = arr.splice(pivotIndex, 1)[0];
  
  // 【步骤3】创建两个空数组，用来存放分组后的元素
  const left = [];   // 存放比基准小或相等的元素
  const right = [];  // 存放比基准大的元素
  
  // 【步骤4】遍历剩余的所有元素，进行分组
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] <= pivot) {
      left.push(arr[i]);   // 比基准小或相等，放左边
    } else {
      right.push(arr[i]);  // 比基准大，放右边
    }
  }
  
  // 【步骤5】递归排序左右两部分，然后合并结果
  // 递归：对左边和右边分别再次调用 quickSort 进行排序
  // 合并：排序后的左边 + 基准 + 排序后的右边
  return quickSort(left).concat(pivot, quickSort(right));
}

console.log('基础实现：', quickSort([4, 3, 5, 2, 1, 6]));

// ==================== 详细的执行过程图解 ====================

/**
 * 【完整执行过程图解】
 * 以数组 [4, 3, 5, 2, 1, 6] 为例，详细展示每一步：
 * 
 * ========== 第一次调用 quickSort([4, 3, 5, 2, 1, 6]) ==========
 * 
 * 原始数组：[4, 3, 5, 2, 1, 6]
 *              0  1  2  3  4  5  （索引）
 * 
 * 步骤1：选择基准
 *   - 数组长度 = 6
 *   - 中间索引 = 6 >> 1 = 3
 *   - 基准 pivot = arr[3] = 2
 * 
 * 步骤2：分组（遍历剩余元素）
 *   - 看 4：4 > 2，放右边  →  left=[], right=[4]
 *   - 看 3：3 > 2，放右边  →  left=[], right=[4, 3]
 *   - 看 5：5 > 2，放右边  →  left=[], right=[4, 3, 5]
 *   - 看 1：1 <= 2，放左边 →  left=[1], right=[4, 3, 5]
 *   - 看 6：6 > 2，放右边  →  left=[1], right=[4, 3, 5, 6]
 * 
 * 步骤3：递归调用
 *   返回：quickSort([1]) + [2] + quickSort([4, 3, 5, 6])
 * 
 * 
 * ========== 递归处理左边：quickSort([1]) ==========
 * 
 * 数组：[1]
 * 长度 = 1，直接返回 [1]  ✓
 * 
 * 
 * ========== 递归处理右边：quickSort([4, 3, 5, 6]) ==========
 * 
 * 原始数组：[4, 3, 5, 6]
 * 
 * 步骤1：选择基准
 *   - 中间索引 = 4 >> 1 = 2
 *   - 基准 pivot = arr[2] = 5
 * 
 * 步骤2：分组
 *   - 看 4：4 <= 5，放左边  →  left=[4], right=[]
 *   - 看 3：3 <= 5，放左边  →  left=[4, 3], right=[]
 *   - 看 6：6 > 5，放右边   →  left=[4, 3], right=[6]
 * 
 * 步骤3：递归调用
 *   返回：quickSort([4, 3]) + [5] + quickSort([6])
 * 
 * 
 * ========== 递归处理：quickSort([4, 3]) ==========
 * 
 * 原始数组：[4, 3]
 * 
 * 步骤1：选择基准
 *   - 中间索引 = 2 >> 1 = 1
 *   - 基准 pivot = arr[1] = 3
 * 
 * 步骤2：分组
 *   - 看 4：4 > 3，放右边  →  left=[], right=[4]
 * 
 * 步骤3：递归调用
 *   返回：quickSort([]) + [3] + quickSort([4])
 *   = [] + [3] + [4]
 *   = [3, 4]  ✓
 * 
 * 
 * ========== 递归处理：quickSort([6]) ==========
 * 
 * 数组：[6]
 * 长度 = 1，直接返回 [6]  ✓
 * 
 * 
 * ========== 回溯合并所有结果 ==========
 * 
 * 从最底层开始往上合并：
 * 
 * 1. quickSort([4, 3]) = [3, 4]
 * 2. quickSort([6]) = [6]
 * 3. quickSort([4, 3, 5, 6]) = [3, 4] + [5] + [6] = [3, 4, 5, 6]
 * 4. quickSort([1]) = [1]
 * 5. quickSort([4, 3, 5, 2, 1, 6]) = [1] + [2] + [3, 4, 5, 6] = [1, 2, 3, 4, 5, 6]  ✓
 * 
 * 最终结果：[1, 2, 3, 4, 5, 6]
 * 
 * 
 * 【递归树可视化】
 * 
 *                    [4,3,5,2,1,6]
 *                    基准=2
 *                   /    |    \
 *                 [1]   [2]  [4,3,5,6]
 *                  ↓           基准=5
 *                 [1]         /   |   \
 *                         [4,3] [5]  [6]
 *                         基准=3      ↓
 *                        /  |  \     [6]
 *                      [] [3] [4]
 *                             ↓   ↓
 *                            [3] [4]
 * 
 * 从底向上合并：
 *   [] + [3] + [4] = [3, 4]
 *   [3, 4] + [5] + [6] = [3, 4, 5, 6]
 *   [1] + [2] + [3, 4, 5, 6] = [1, 2, 3, 4, 5, 6]
 */

/**
 * 快速排序 - 原地排序版本（推荐 ⭐⭐⭐⭐⭐）
 * 
 * 【与基础版本的区别】
 * 基础版本：创建新数组 left 和 right，占用额外空间
 * 原地版本：直接在原数组上交换元素，不创建新数组，更节省空间
 * 
 * 【核心思想】
 * 使用"双指针"技术，在原数组上直接进行分区：
 * - i 指针：标记"小于基准的区域"的右边界
 * - j 指针：遍历数组，寻找小于基准的元素
 * - 当找到小于基准的元素时，将它交换到 i 指针的位置
 * 
 * @param {number[]} arr - 需要排序的数组
 * @param {number} left - 左边界索引
 * @param {number} right - 右边界索引
 * @returns {number[]} 返回排序后的数组（原地修改）
 */
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  // 递归终止条件：如果左边界 >= 右边界，说明只有 0 或 1 个元素，无需排序
  if (left >= right) return arr;
  
  // 分区操作：将数组分为两部分，并返回基准元素的最终位置
  const pivotIndex = partition(arr, left, right);
  
  // 递归排序基准左边的部分（比基准小的元素）
  quickSortInPlace(arr, left, pivotIndex - 1);
  
  // 递归排序基准右边的部分（比基准大的元素）
  quickSortInPlace(arr, pivotIndex + 1, right);
  
  return arr;
}

/**
 * 分区函数（Partition）- 快速排序的核心
 * 
 * 【目标】
 * 将数组分为两部分：左边都 <= 基准，右边都 > 基准
 * 
 * 【双指针工作原理】
 * i 指针：标记"小于等于基准的区域"的右边界
 * j 指针：从左到右遍历数组
 * 
 * 【关键思路】
 * 维护一个不变式（invariant）：
 * - arr[left...i] 的所有元素都 <= pivot
 * - arr[i+1...j-1] 的所有元素都 > pivot
 * - arr[j...right-1] 还未处理
 * - arr[right] 是基准元素
 * 
 * @param {number[]} arr - 数组
 * @param {number} left - 左边界
 * @param {number} right - 右边界
 * @returns {number} 返回基准元素的最终位置
 */
function partition(arr, left, right) {
  // 【步骤1】选择最右边的元素作为基准
  const pivot = arr[right];
  
  // 【步骤2】初始化 i 指针
  // i = left - 1 表示"小于等于基准的区域"一开始是空的
  let i = left - 1;
  
  // 【步骤3】j 指针遍历数组，从 left 到 right-1
  for (let j = left; j < right; j++) {
    // 如果当前元素 <= 基准
    if (arr[j] <= pivot) {
      // 扩大"小于等于基准的区域"
      i++;
      // 将当前元素交换到这个区域的末尾
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    // 如果当前元素 > 基准，j 继续前进，不做任何操作
  }
  
  // 【步骤4】将基准元素放到正确的位置
  // 此时 i+1 的位置就是基准应该在的位置
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  
  // 返回基准元素的最终位置
  return i + 1;
}

console.log('原地排序：', quickSortInPlace([4, 3, 5, 2, 1, 6]));

// ==================== 分区函数详细图解 ====================

/**
 * 【分区函数执行过程详解】
 * 以数组 [4, 3, 5, 2, 1, 6] 为例，基准 = 6
 * 
 * 初始状态：
 * arr = [4, 3, 5, 2, 1, 6]
 *        ↑              ↑
 *      left           right
 * pivot = 6
 * i = -1（小于等于基准的区域为空）
 * 
 * 
 * 第1轮：j = 0，arr[0] = 4
 * ┌────────────────────────────────────┐
 * │ arr[0] = 4 <= 6 吗？ 是！          │
 * │ i++ → i = 0                        │
 * │ 交换 arr[0] 和 arr[0]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │        ↑                           │
 * │        i                           │
 * └────────────────────────────────────┘
 * 
 * 第2轮：j = 1，arr[1] = 3
 * ┌────────────────────────────────────┐
 * │ arr[1] = 3 <= 6 吗？ 是！          │
 * │ i++ → i = 1                        │
 * │ 交换 arr[1] 和 arr[1]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │           ↑                        │
 * │           i                        │
 * └────────────────────────────────────┘
 * 
 * 第3轮：j = 2，arr[2] = 5
 * ┌────────────────────────────────────┐
 * │ arr[2] = 5 <= 6 吗？ 是！          │
 * │ i++ → i = 2                        │
 * │ 交换 arr[2] 和 arr[2]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │              ↑                     │
 * │              i                     │
 * └────────────────────────────────────┘
 * 
 * 第4轮：j = 3，arr[3] = 2
 * ┌────────────────────────────────────┐
 * │ arr[3] = 2 <= 6 吗？ 是！          │
 * │ i++ → i = 3                        │
 * │ 交换 arr[3] 和 arr[3]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │                 ↑                  │
 * │                 i                  │
 * └────────────────────────────────────┘
 * 
 * 第5轮：j = 4，arr[4] = 1
 * ┌────────────────────────────────────┐
 * │ arr[4] = 1 <= 6 吗？ 是！          │
 * │ i++ → i = 4                        │
 * │ 交换 arr[4] 和 arr[4]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │                    ↑               │
 * │                    i               │
 * └────────────────────────────────────┘
 * 
 * 循环结束，将基准放到正确位置：
 * ┌────────────────────────────────────┐
 * │ 交换 arr[i+1] 和 arr[right]        │
 * │ 交换 arr[5] 和 arr[5]              │
 * │ arr = [4, 3, 5, 2, 1, 6]           │
 * │                       ↑            │
 * │                   基准位置         │
 * │ 返回 5                             │
 * └────────────────────────────────────┘
 * 
 * 
 * 【更复杂的例子】
 * 以数组 [3, 7, 8, 5, 2, 1, 9, 4] 为例，基准 = 4
 * 
 * 初始：arr = [3, 7, 8, 5, 2, 1, 9, 4]
 * pivot = 4, i = -1
 * 
 * j=0: arr[0]=3<=4 ✓ → i=0, 交换arr[0]和arr[0] → [3, 7, 8, 5, 2, 1, 9, 4]
 * j=1: arr[1]=7<=4 ✗ → 不交换                  → [3, 7, 8, 5, 2, 1, 9, 4]
 * j=2: arr[2]=8<=4 ✗ → 不交换                  → [3, 7, 8, 5, 2, 1, 9, 4]
 * j=3: arr[3]=5<=4 ✗ → 不交换                  → [3, 7, 8, 5, 2, 1, 9, 4]
 * j=4: arr[4]=2<=4 ✓ → i=1, 交换arr[1]和arr[4] → [3, 2, 8, 5, 7, 1, 9, 4]
 * j=5: arr[5]=1<=4 ✓ → i=2, 交换arr[2]和arr[5] → [3, 2, 1, 5, 7, 8, 9, 4]
 * j=6: arr[6]=9<=4 ✗ → 不交换                  → [3, 2, 1, 5, 7, 8, 9, 4]
 * 
 * 最后：交换arr[3]和arr[7] → [3, 2, 1, 4, 7, 8, 9, 5]
 *                              -------  ↑  ----------
 *                              <= 4    基准    > 4
 * 返回 3
 * 
 * 可以看到：
 * - 索引 0~2 的元素 [3, 2, 1] 都 <= 4
 * - 索引 3 是基准 4
 * - 索引 4~7 的元素 [7, 8, 9, 5] 都 > 4
 */

// ==================== 复杂度分析 ====================

/**
 * 【时间复杂度】
 * 
 * 1. 最好情况 O(n log n)：
 *    - 每次分区都将数组平均分成两半
 *    - 递归树的高度 = log₂n
 *    - 每层需要遍历所有 n 个元素
 *    - 总时间 = 树高 × 每层时间 = log n × n = O(n log n)
 * 
 * 2. 最坏情况 O(n²)：
 *    - 每次分区只分出一个元素（数组已排序或逆序）
 *    - 递归树退化成链表，高度 = n
 *    - 总时间 = n + (n-1) + ... + 1 = n(n+1)/2 ≈ O(n²)
 * 
 * 3. 平均情况 O(n log n)
 * 
 * 
 * 【空间复杂度】
 * 
 * 1. 基础实现：O(n)
 *    - 递归调用栈：O(log n) ~ O(n)
 *    - 创建新数组：O(n)
 * 
 * 2. 原地排序：O(log n)
 *    - 只有递归调用栈
 *    - 不创建额外数组
 */

// ==================== 特点总结 ====================

/**
 * 快速排序特点：
 * 
 * ┌────────────────┬──────────────────────────────────────┐
 * │   特性         │              说明                    │
 * ├────────────────┼──────────────────────────────────────┤
 * │ 平均时间       │  O(n log n)                          │
 * │ 最坏时间       │  O(n²)                               │
 * │ 空间复杂度     │  O(log n) 原地排序                   │
 * │ 稳定性         │  不稳定                              │
 * │ 适用场景       │  大规模数据，不要求稳定性            │
 * └────────────────┴──────────────────────────────────────┘
 * 
 * 优点：
 * - 平均性能优秀，最常用的排序算法之一
 * - 原地排序，空间效率高
 * - 缓存友好（访问连续内存）
 * 
 * 缺点：
 * - 最坏情况性能差 O(n²)
 * - 不稳定（相同元素的相对位置可能改变）
 * 
 * 优化技巧：
 * - 随机选择基准（避免最坏情况）
 * - 三数取中法（取首、中、尾的中位数作为基准）
 * - 小数组使用插入排序（阈值通常为 10-20）
 * 
 * 与其他排序算法对比：
 * ┌──────────┬──────────┬──────────┬────────┬────────┐
 * │ 算法     │ 平均时间 │ 最坏时间 │  空间  │ 稳定性 │
 * ├──────────┼──────────┼──────────┼────────┼────────┤
 * │ 快速排序 │O(n log n)│  O(n²)   │O(log n)│ 不稳定 │
 * │ 归并排序 │O(n log n)│O(n log n)│  O(n)  │  稳定  │
 * │ 堆排序   │O(n log n)│O(n log n)│  O(1)  │ 不稳定 │
 * └──────────┴──────────┴──────────┴────────┴────────┘
 */

// ==================== 测试用例 ====================

console.log('\n--- 测试用例 ---');
console.log('空数组：', quickSortInPlace([]));
console.log('单元素：', quickSortInPlace([1]));
console.log('已排序：', quickSortInPlace([1, 2, 3, 4, 5]));
console.log('逆序：', quickSortInPlace([5, 4, 3, 2, 1]));
console.log('重复元素：', quickSortInPlace([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]));
console.log('负数：', quickSortInPlace([-3, -1, -4, -1, -5, -9, -2]));
console.log('混合：', quickSortInPlace([3, -1, 4, 0, -5, 2, 8, -3]));







