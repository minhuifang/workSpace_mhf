// ==================== 最长递增子序列（Longest Increasing Subsequence, LIS）====================

/**
 * 【问题描述】
 * 给定一个整数数组，找出其中最长递增子序列的长度。
 * 
 * 【什么是子序列】
 * 子序列是从原数组中删除一些（或不删除）元素后，剩余元素保持原有顺序形成的序列。
 * 注意：子序列不要求元素连续！
 * 
 * 【例子】
 * 数组：[10, 9, 2, 5, 3, 7, 101, 18]
 * 
 * 一些递增子序列：
 * - [2, 5, 7, 101] - 长度 4 ✓ 最长
 * - [2, 3, 7, 18] - 长度 4 ✓ 最长
 * - [2, 5, 7, 18] - 长度 4 ✓ 最长
 * - [10, 101] - 长度 2
 * - [2, 3] - 长度 2
 * 
 * 最长递增子序列的长度是 4
 * 
 * 【生活中的例子】
 * 想象你在玩一个游戏，每天都有一个分数：
 * [10, 9, 2, 5, 3, 7, 101, 18]
 * 
 * 你想找出"连续进步"的最长天数（可以跳过某些天）：
 * - 第3天(2分) → 第4天(5分) → 第6天(7分) → 第7天(101分)
 * - 这样你有4天是在持续进步的！
 */

/**
 * 方法1：动态规划（DP）- 最容易理解的版本
 * 
 * 【核心思想】
 * dp[i] 表示：以 array[i] 结尾的最长递增子序列的长度
 * 
 * 【状态转移方程】
 * dp[i] = max(dp[j] + 1)，其中 0 <= j < i 且 array[j] < array[i]
 * 
 * 【算法步骤】
 * 1. 初始化：每个位置的 dp 值都是 1（至少包含自己）
 * 2. 对于每个位置 i，查看它前面的所有位置 j
 * 3. 如果 array[j] < array[i]，说明可以接在 j 后面
 * 4. 更新 dp[i] = max(dp[i], dp[j] + 1)
 * 5. 最后返回 dp 数组中的最大值
 * 
 * @param {number[]} array - 输入数组
 * @returns {number} 最长递增子序列的长度
 * 
 * 时间复杂度：O(n²)
 * - 外层循环 n 次
 * - 内层循环最多 n 次
 * 
 * 空间复杂度：O(n)
 * - dp 数组占用 n 个空间
 */
function lis(array) {
  // 边界情况：空数组
  if (array.length === 0) return 0;
  
  // 【步骤1】创建 dp 数组，初始化为 1
  // dp[i] 表示以 array[i] 结尾的最长递增子序列的长度
  const dp = new Array(array.length).fill(1);
  
  // 【步骤2】填充 dp 数组
  // i 从 1 开始，因为 dp[0] = 1 已经确定
  for (let i = 1; i < array.length; i++) {
    // 【步骤3】检查 i 之前的所有位置 j
    for (let j = 0; j < i; j++) {
      // 如果 array[j] < array[i]，说明可以把 array[i] 接在 array[j] 后面
      if (array[j] < array[i]) {
        // 更新 dp[i]：在 dp[j] 的基础上加 1
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  
  // 【步骤4】找出 dp 数组中的最大值
  let result = 1;
  for (let i = 0; i < dp.length; i++) {
    result = Math.max(result, dp[i]);
  }
  
  return result;
}

console.log('方法1 - 动态规划：', lis([10, 9, 2, 5, 3, 7, 101, 18])); // 4

// ==================== 详细执行过程图解 ====================

/**
 * 【完整执行过程图解】
 * 以数组 [10, 9, 2, 5, 3, 7, 101, 18] 为例
 * 
 * 初始状态：
 * array = [10, 9, 2, 5, 3, 7, 101, 18]
 * dp    = [ 1, 1, 1, 1, 1, 1,   1,  1]  （初始化为 1）
 * 
 * 
 * ========== i = 1，处理 array[1] = 9 ==========
 * 比较 j = 0：array[0]=10 < 9? 否，跳过
 * dp[1] 保持为 1
 * 
 * dp = [1, 1, 1, 1, 1, 1, 1, 1]
 * 
 * 
 * ========== i = 2，处理 array[2] = 2 ==========
 * 比较 j = 0：array[0]=10 < 2? 否，跳过
 * 比较 j = 1：array[1]=9 < 2? 否，跳过
 * dp[2] 保持为 1
 * 
 * dp = [1, 1, 1, 1, 1, 1, 1, 1]
 * 
 * 
 * ========== i = 3，处理 array[3] = 5 ==========
 * 比较 j = 0：array[0]=10 < 5? 否，跳过
 * 比较 j = 1：array[1]=9 < 5? 否，跳过
 * 比较 j = 2：array[2]=2 < 5? 是！
 *   dp[3] = max(dp[3], dp[2] + 1) = max(1, 1 + 1) = 2
 * 
 * dp = [1, 1, 1, 2, 1, 1, 1, 1]
 *                ↑ 更新为 2
 * 
 * 
 * ========== i = 4，处理 array[4] = 3 ==========
 * 比较 j = 0：array[0]=10 < 3? 否，跳过
 * 比较 j = 1：array[1]=9 < 3? 否，跳过
 * 比较 j = 2：array[2]=2 < 3? 是！
 *   dp[4] = max(dp[4], dp[2] + 1) = max(1, 1 + 1) = 2
 * 比较 j = 3：array[3]=5 < 3? 否，跳过
 * 
 * dp = [1, 1, 1, 2, 2, 1, 1, 1]
 *                   ↑ 更新为 2
 * 
 * 
 * ========== i = 5，处理 array[5] = 7 ==========
 * 比较 j = 0：array[0]=10 < 7? 否，跳过
 * 比较 j = 1：array[1]=9 < 7? 否，跳过
 * 比较 j = 2：array[2]=2 < 7? 是！
 *   dp[5] = max(dp[5], dp[2] + 1) = max(1, 1 + 1) = 2
 * 比较 j = 3：array[3]=5 < 7? 是！
 *   dp[5] = max(dp[5], dp[3] + 1) = max(2, 2 + 1) = 3
 * 比较 j = 4：array[4]=3 < 7? 是！
 *   dp[5] = max(dp[5], dp[4] + 1) = max(3, 2 + 1) = 3
 * 
 * dp = [1, 1, 1, 2, 2, 3, 1, 1]
 *                      ↑ 更新为 3
 * 
 * 
 * ========== i = 6，处理 array[6] = 101 ==========
 * 比较 j = 0：array[0]=10 < 101? 是！
 *   dp[6] = max(dp[6], dp[0] + 1) = max(1, 1 + 1) = 2
 * 比较 j = 1：array[1]=9 < 101? 是！
 *   dp[6] = max(dp[6], dp[1] + 1) = max(2, 1 + 1) = 2
 * 比较 j = 2：array[2]=2 < 101? 是！
 *   dp[6] = max(dp[6], dp[2] + 1) = max(2, 1 + 1) = 2
 * 比较 j = 3：array[3]=5 < 101? 是！
 *   dp[6] = max(dp[6], dp[3] + 1) = max(2, 2 + 1) = 3
 * 比较 j = 4：array[4]=3 < 101? 是！
 *   dp[6] = max(dp[6], dp[4] + 1) = max(3, 2 + 1) = 3
 * 比较 j = 5：array[5]=7 < 101? 是！
 *   dp[6] = max(dp[6], dp[5] + 1) = max(3, 3 + 1) = 4
 * 
 * dp = [1, 1, 1, 2, 2, 3, 4, 1]
 *                         ↑ 更新为 4
 * 
 * 
 * ========== i = 7，处理 array[7] = 18 ==========
 * 比较 j = 0：array[0]=10 < 18? 是！
 *   dp[7] = max(dp[7], dp[0] + 1) = max(1, 1 + 1) = 2
 * 比较 j = 1：array[1]=9 < 18? 是！
 *   dp[7] = max(dp[7], dp[1] + 1) = max(2, 1 + 1) = 2
 * 比较 j = 2：array[2]=2 < 18? 是！
 *   dp[7] = max(dp[7], dp[2] + 1) = max(2, 1 + 1) = 2
 * 比较 j = 3：array[3]=5 < 18? 是！
 *   dp[7] = max(dp[7], dp[3] + 1) = max(2, 2 + 1) = 3
 * 比较 j = 4：array[4]=3 < 18? 是！
 *   dp[7] = max(dp[7], dp[4] + 1) = max(3, 2 + 1) = 3
 * 比较 j = 5：array[5]=7 < 18? 是！
 *   dp[7] = max(dp[7], dp[5] + 1) = max(3, 3 + 1) = 4
 * 比较 j = 6：array[6]=101 < 18? 否，跳过
 * 
 * dp = [1, 1, 1, 2, 2, 3, 4, 4]
 *                            ↑ 更新为 4
 * 
 * 
 * 最终 dp 数组：[1, 1, 1, 2, 2, 3, 4, 4]
 * 最大值 = 4
 * 
 * 【对应的最长递增子序列】
 * 一种可能的序列：[2, 5, 7, 101]
 * 另一种可能的序列：[2, 3, 7, 18]
 */

/**
 * 方法2：动态规划 + 返回具体序列
 * 
 * 【核心问题】
 * 方法1只能告诉我们最长递增子序列的长度是多少，m
 * 但不知道具体是哪些元素组成的。
 * 
 * 【解决思路】
 * 使用一个额外的 parent 数组来"记录路径"：
 * - parent[i] 记录：位置 i 的元素是从哪个位置"接"过来的
 * - 就像记录"我是从哪里来的"
 * - 最后通过回溯 parent 数组，就能还原出完整的序列
 * 
 * 【类比理解】
 * 想象你在玩一个接龙游戏：
 * - 每张牌都记住"我是接在哪张牌后面的"
 * - 游戏结束后，从最后一张牌开始往回找
 * - 就能还原出整个接龙序列
 * 
 * @param {number[]} array - 输入数组
 * @returns {number[]} 最长递增子序列
 */
function lisWithSequence(array) {
  if (array.length === 0) return [];
  
  const n = array.length;
  
  // dp[i]：以 array[i] 结尾的最长递增子序列的长度
  const dp = new Array(n).fill(1);
  
  // parent[i]：记录 array[i] 是从哪个位置转移来的
  // -1 表示没有前驱（自己就是起点）
  const parent = new Array(n).fill(-1);
  
  // 【步骤1】填充 dp 数组和 parent 数组
  for (let i = 1; i < n; i++) {
    // 检查 i 之前的所有位置 j
    for (let j = 0; j < i; j++) {
      // 如果可以接在 j 后面，并且接上后长度更长
      if (array[j] < array[i] && dp[j] + 1 > dp[i]) {
        dp[i] = dp[j] + 1;    // 更新长度
        parent[i] = j;         // 记录来源：i 是从 j 接过来的
      }
    }
  }
  
  // 【步骤2】找到最长递增子序列的终点位置
  let maxLen = 1;      // 最长长度
  let maxIndex = 0;    // 最长序列的最后一个元素的位置
  
  for (let i = 0; i < n; i++) {
    if (dp[i] > maxLen) {
      maxLen = dp[i];
      maxIndex = i;
    }
  }
  
  // 【步骤3】回溯构建序列
  // 从终点开始，沿着 parent 数组往回走
  const result = [];
  let current = maxIndex;  // 从最后一个元素开始
  
  while (current !== -1) {
    // 将当前位置的元素添加到结果的开头
    result.unshift(array[current]);
    // 移动到前一个位置
    current = parent[current];
  }
  
  return result;
}

console.log('方法2 - 返回具体序列：', lisWithSequence([10, 9, 2, 5, 3, 7, 101, 18]));

// ==================== 方法2详细执行过程图解 ====================

/**
 * 【完整执行过程图解】
 * 以数组 [10, 9, 2, 5, 3, 7, 101, 18] 为例
 * 
 * 初始状态：
 * array  = [10,  9,  2,  5,  3,  7, 101, 18]
 * 索引   =   0   1   2   3   4   5    6   7
 * dp     = [ 1,  1,  1,  1,  1,  1,   1,  1]
 * parent = [-1, -1, -1, -1, -1, -1,  -1, -1]
 * 
 * 
 * ========== i = 3，处理 array[3] = 5 ==========
 * 
 * 检查 j = 2：array[2]=2 < 5 ✓
 *   dp[2] + 1 = 1 + 1 = 2 > dp[3]=1 ✓
 *   更新：dp[3] = 2, parent[3] = 2
 *   
 *   含义：5 可以接在 2 后面，形成 [2, 5]
 *   parent[3] = 2 表示：索引3的元素(5)是从索引2的元素(2)接过来的
 * 
 * dp     = [1, 1, 1, 2, 1, 1, 1, 1]
 * parent = [-1, -1, -1, 2, -1, -1, -1, -1]
 *                      ↑
 *                   记录来源
 * 
 * 
 * ========== i = 5，处理 array[5] = 7 ==========
 * 
 * 检查 j = 2：array[2]=2 < 7 ✓
 *   dp[2] + 1 = 2，更新 dp[5] = 2, parent[5] = 2
 * 
 * 检查 j = 3：array[3]=5 < 7 ✓
 *   dp[3] + 1 = 3 > dp[5]=2 ✓
 *   更新：dp[5] = 3, parent[5] = 3
 *   
 *   含义：7 可以接在 5 后面，形成 [2, 5, 7]
 *   parent[5] = 3 表示：索引5的元素(7)是从索引3的元素(5)接过来的
 * 
 * dp     = [1, 1, 1, 2, 2, 3, 1, 1]
 * parent = [-1, -1, -1, 2, -1, 3, -1, -1]
 *                               ↑
 *                            记录来源
 * 
 * 
 * ========== i = 6，处理 array[6] = 101 ==========
 * 
 * 检查多个位置后，最优的是从 j = 5 转移：
 *   dp[5] + 1 = 4
 *   更新：dp[6] = 4, parent[6] = 5
 *   
 *   含义：101 可以接在 7 后面，形成 [2, 5, 7, 101]
 *   parent[6] = 5 表示：索引6的元素(101)是从索引5的元素(7)接过来的
 * 
 * dp     = [1, 1, 1, 2, 2, 3, 4, 1]
 * parent = [-1, -1, -1, 2, -1, 3, 5, -1]
 *                                  ↑
 *                               记录来源
 * 
 * 
 * ========== 最终状态 ==========
 * 
 * array  = [10,  9,  2,  5,  3,  7, 101, 18]
 * 索引   =   0   1   2   3   4   5    6   7
 * dp     = [ 1,  1,  1,  2,  2,  3,   4,  4]
 * parent = [-1, -1, -1,  2, -1,  3,   5,  3]
 * 
 * 
 * ========== 找到终点 ==========
 * 
 * 遍历 dp 数组，找到最大值：
 * - maxLen = 4
 * - maxIndex = 6（索引6和7都是4，我们找到第一个）
 * 
 * 从索引 6 开始回溯：
 * 
 * 
 * ========== 回溯构建序列 ==========
 * 
 * 【回溯过程可视化】
 * 
 * current = 6
 * ┌─────────────────────────────────────────┐
 * │ array[6] = 101                          │
 * │ result = [101]                          │
 * │ parent[6] = 5  →  跳到索引 5            │
 * └─────────────────────────────────────────┘
 * 
 * current = 5
 * ┌─────────────────────────────────────────┐
 * │ array[5] = 7                            │
 * │ result = [7, 101]                       │
 * │ parent[5] = 3  →  跳到索引 3            │
 * └─────────────────────────────────────────┘
 * 
 * current = 3
 * ┌─────────────────────────────────────────┐
 * │ array[3] = 5                            │
 * │ result = [5, 7, 101]                    │
 * │ parent[3] = 2  →  跳到索引 2            │
 * └─────────────────────────────────────────┘
 * 
 * current = 2
 * ┌─────────────────────────────────────────┐
 * │ array[2] = 2                            │
 * │ result = [2, 5, 7, 101]                 │
 * │ parent[2] = -1  →  到达起点，停止      │
 * └─────────────────────────────────────────┘
 * 
 * 最终结果：[2, 5, 7, 101]
 * 
 * 
 * 【链表式理解】
 * 
 * parent 数组就像一个"链表"，记录了序列的连接关系：
 * 
 *   2  ←─  5  ←─  7  ←─  101
 *  [2]    [3]    [5]    [6]     (索引)
 *   ↑      ↑      ↑      ↑
 *  -1      2      3      5      (parent值)
 * 
 * 从 101 开始，沿着箭头往回走：
 * 101 → 7 → 5 → 2 → 结束
 * 
 * 
 * 【为什么用 unshift 而不是 push】
 * 
 * 因为我们是从后往前回溯的：
 * - 先找到 101（最后一个）
 * - 再找到 7
 * - 再找到 5
 * - 最后找到 2（第一个）
 * 
 * 所以需要用 unshift 把元素插入到数组开头，
 * 这样最终得到的顺序才是正确的：[2, 5, 7, 101]
 * 
 * 如果用 push：
 * - 会得到 [101, 7, 5, 2]（顺序反了！）
 */

/**
 * 【关键点总结】
 * 
 * 1. parent 数组的作用：
 *    - 记录每个位置的"前驱"
 *    - parent[i] = j 表示：i 是从 j 转移来的
 *    - -1 表示没有前驱，是起点
 * 
 * 2. 为什么需要 parent 数组：
 *    - dp 数组只记录了长度信息
 *    - 但不知道具体是哪些元素
 *    - parent 数组帮我们"记住路径"
 * 
 * 3. 回溯的过程：
 *    - 从最长序列的终点开始
 *    - 沿着 parent 数组往回走
 *    - 直到遇到 -1（起点）
 * 
 * 4. 时间复杂度：O(n²) + O(n) = O(n²)
 *    - 填充 dp 和 parent：O(n²)
 *    - 找最大值：O(n)
 *    - 回溯构建：O(n)
 * 
 * 5. 空间复杂度：O(n)
 *    - dp 数组：O(n)
 *    - parent 数组：O(n)
 *    - result 数组：O(n)
 */


/**
 * 方法3：二分查找优化（贪心 + 二分）
 * 
 * 【核心思想】
 * 维护一个数组 tails，tails[i] 表示长度为 i+1 的递增子序列的最小末尾元素
 * 
 * 【为什么这样做】
 * 如果我们想让递增子序列尽可能长，就要让每个长度的子序列的末尾元素尽可能小
 * 这样后面的元素更容易接上去
 * 
 * 【算法步骤】
 * 1. 遍历数组中的每个元素 num
 * 2. 在 tails 中二分查找第一个 >= num 的位置
 * 3. 如果找到，替换该位置的值（贪心：用更小的值）
 * 4. 如果没找到，说明 num 比所有值都大，追加到 tails 末尾
 * 
 * @param {number[]} array - 输入数组
 * @returns {number} 最长递增子序列的长度
 * 
 * 时间复杂度：O(n log n)
 * - 遍历数组 O(n)
 * - 每次二分查找 O(log n)
 * 
 * 空间复杂度：O(n)
 */
function lisOptimized(array) {
  if (array.length === 0) return 0;
  
  // tails[i] 表示长度为 i+1 的递增子序列的最小末尾元素
  const tails = [];
  
  for (let num of array) {
    // 二分查找第一个 >= num 的位置
    let left = 0;
    let right = tails.length;
    
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (tails[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }
    
    // 如果 left == tails.length，说明 num 比所有元素都大
    if (left === tails.length) {
      tails.push(num);
    } else {
      // 替换为更小的值（贪心策略）
      tails[left] = num;
    }
  }
  
  return tails.length;
}

console.log('方法3 - 二分优化：', lisOptimized([10, 9, 2, 5, 3, 7, 101, 18]));

// ==================== 二分查找优化版本的执行过程 ====================

/**
 * 【二分查找版本执行过程】
 * 以数组 [10, 9, 2, 5, 3, 7, 101, 18] 为例
 * 
 * 初始：tails = []
 * 
 * 处理 10：
 *   tails 为空，直接追加
 *   tails = [10]
 * 
 * 处理 9：
 *   二分查找 >= 9 的位置：找到索引 0（tails[0]=10）
 *   替换：tails[0] = 9
 *   tails = [9]
 *   （长度为1的子序列，末尾用9比用10更好）
 * 
 * 处理 2：
 *   二分查找 >= 2 的位置：找到索引 0（tails[0]=9）
 *   替换：tails[0] = 2
 *   tails = [2]
 *   （长度为1的子序列，末尾用2比用9更好）
 * 
 * 处理 5：
 *   二分查找 >= 5 的位置：没找到（5比所有元素都大）
 *   追加：tails.push(5)
 *   tails = [2, 5]
 *   （可以形成长度为2的子序列：[2, 5]）
 * 
 * 处理 3：
 *   二分查找 >= 3 的位置：找到索引 1（tails[1]=5）
 *   替换：tails[1] = 3
 *   tails = [2, 3]
 *   （长度为2的子序列，末尾用3比用5更好）
 * 
 * 处理 7：
 *   二分查找 >= 7 的位置：没找到
 *   追加：tails.push(7)
 *   tails = [2, 3, 7]
 *   （可以形成长度为3的子序列：[2, 3, 7]）
 * 
 * 处理 101：
 *   二分查找 >= 101 的位置：没找到
 *   追加：tails.push(101)
 *   tails = [2, 3, 7, 101]
 *   （可以形成长度为4的子序列：[2, 3, 7, 101]）
 * 
 * 处理 18：
 *   二分查找 >= 18 的位置：找到索引 3（tails[3]=101）
 *   替换：tails[3] = 18
 *   tails = [2, 3, 7, 18]
 *   （长度为4的子序列，末尾用18比用101更好）
 * 
 * 最终：tails.length = 4
 * 
 * 注意：tails 数组本身不一定是实际的最长递增子序列，
 * 但它的长度就是最长递增子序列的长度！
 */

// ==================== 复杂度分析和总结 ====================

/**
 * 【时间复杂度对比】
 * 
 * 方法1 - 动态规划：O(n²)
 * - 两层循环，每层最多 n 次
 * - 适合：数据量较小（n < 1000）
 * 
 * 方法3 - 二分优化：O(n log n)
 * - 外层循环 n 次，每次二分查找 O(log n)
 * - 适合：数据量较大（n >= 1000）
 * 
 * 
 * 【空间复杂度】
 * 
 * 两种方法都是 O(n)
 * 
 * 
 * 【使用场景】
 * 
 * 1. LeetCode 300. 最长递增子序列
 * 2. 俄罗斯套娃信封问题
 * 3. 股票交易问题的变种
 * 4. 版本号排序
 * 5. Vue3 中的 diff 算法优化
 */

// ==================== 测试用例 ====================

console.log('\n--- 测试用例 ---');
console.log('空数组：', lis([])); // 0
console.log('单元素：', lis([1])); // 1
console.log('递增数组：', lis([1, 2, 3, 4, 5])); // 5
console.log('递减数组：', lis([5, 4, 3, 2, 1])); // 1
console.log('示例1：', lis([10, 9, 2, 5, 3, 7, 101, 18])); // 4
console.log('示例2：', lis([0, 1, 0, 3, 2, 3])); // 4
console.log('示例3：', lis([7, 7, 7, 7, 7])); // 1

console.log('\n--- 返回具体序列 ---');
console.log('示例1：', lisWithSequence([10, 9, 2, 5, 3, 7, 101, 18]));
console.log('示例2：', lisWithSequence([0, 1, 0, 3, 2, 3]));



