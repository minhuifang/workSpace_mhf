# 性能优化

> 前端性能优化：CSS vs JS 动画、回流与重绘等核心知识

## 目录

- [CSS vs JS 动画](#css-vs-js-动画)
- [回流与重绘优化](#回流与重绘优化)

---

## CSS vs JS 动画

### 通过 JS 实现一个动画和通过 CSS 实现一个动画，有什么区别，哪个性能更好？

#### CSS 动画 vs JS 动画

| 特性 | CSS 动画 | JS 动画 |
|------|----------|---------|
| **性能** | 更好（GPU 加速） | 较差（主线程） |
| **复杂度** | 简单动画 | 复杂动画 |
| **控制能力** | 有限 | 强大 |
| **兼容性** | 好 | 好 |
| **调试** | 较难 | 容易 |

#### 性能对比

**CSS 动画性能更好！**

**原因：**

1. **GPU 加速**
   - CSS 动画可以触发 GPU 加速
   - 使用 `transform` 和 `opacity` 不会触发重排（reflow）

2. **浏览器优化**
   - 浏览器会自动优化 CSS 动画
   - 可以在合成线程（Compositor Thread）执行

3. **主线程空闲**
   - CSS 动画不占用 JavaScript 主线程
   - JS 动画会阻塞其他 JS 执行

#### CSS 动画示例


/* 使用 transition */
.box {
  transition: transform 0.3s ease;
}

.box:hover {
  transform: translateX(100px);
}

/* 使用 animation */
@keyframes slide {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(100px);
  }
}

.box {
  animation: slide 1s ease infinite;
}


#### JS 动画示例


// 使用 requestAnimationFrame
function animate() {
  const box = document.querySelector('.box');
  let pos = 0;
  
  function step() {
    pos += 2;
    box.style.transform = `translateX(${pos}px)`;
    
    if (pos < 100) {
      requestAnimationFrame(step);
    }
  }
  
  requestAnimationFrame(step);
}

// 使用 Web Animations API
const box = document.querySelector('.box');
box.animate([
  { transform: 'translateX(0)' },
  { transform: 'translateX(100px)' }
], {
  duration: 1000,
  easing: 'ease-in-out'
});


#### 性能优化建议

**1. 优先使用 CSS 动画**


/* ✅ 好：使用 transform（不触发重排） */
.box {
  transform: translateX(100px);
}

/* ❌ 差：使用 left（触发重排） */
.box {
  left: 100px;
}


**2. 使用 will-change 提示浏览器**


.box {
  will-change: transform, opacity;
}


**3. 避免触发重排的属性**


// 触发重排的属性（慢）：
// width, height, top, left, margin, padding

// 不触发重排的属性（快）：
// transform, opacity


**4. 使用 requestAnimationFrame**


// ❌ 不要使用 setInterval
setInterval(() => {
  box.style.left = pos + 'px';
}, 16);

// ✅ 使用 requestAnimationFrame
function animate() {
  box.style.transform = `translateX(${pos}px)`;
  requestAnimationFrame(animate);
}


#### 使用场景选择

**使用 CSS 动画：**
- 简单的过渡效果
- 悬停效果
- 页面加载动画
- 性能要求高的场景

**使用 JS 动画：**
- 复杂的交互动画
- 需要精确控制的动画
- 需要根据用户输入动态调整
- 需要暂停/恢复/倒放

---

## 回流与重绘优化

### 回流(Reflow)和重绘(Repaint)的区别及场景

#### 概念区分

**回流(Reflow/重排):**
- 当元素的**几何属性**发生变化时
- 浏览器需要**重新计算元素的位置和大小**
- 会影响页面布局
- **性能开销大**

**重绘(Repaint):**
- 当元素的**样式**发生变化，但不影响布局时
- 浏览器只需要**重新绘制元素的外观**
- 不影响页面布局
- **性能开销较小**

#### 关系

**回流一定会引起重绘，但重绘不一定引起回流**


// 回流(改变布局) → 重新计算位置 → 重新绘制
element.style.width = '200px';  // 回流 + 重绘

// 重绘(只改变外观) → 重新绘制
element.style.color = 'red';    // 只重绘


#### 触发回流的操作

**1. 改变几何属性**


// 尺寸
element.style.width = '100px';
element.style.height = '100px';
element.style.padding = '10px';
element.style.margin = '10px';
element.style.border = '1px solid red';

// 位置
element.style.top = '10px';
element.style.left = '10px';

// 显示/隐藏
element.style.display = 'none';  // 回流
element.style.visibility = 'hidden';  // 不回流，只重绘


**2. 添加/删除 DOM 元素**


// 添加元素
parent.appendChild(newElement);

// 删除元素
parent.removeChild(element);

// 修改内容
element.innerHTML = 'new content';


**3. 获取某些属性**（会强制浏览器立即计算）


// 这些操作会触发浏览器立即回流
const width = element.offsetWidth;
const height = element.offsetHeight;
const top = element.offsetTop;
const left = element.offsetLeft;

const scrollTop = element.scrollTop;
const scrollHeight = element.scrollHeight;

const clientWidth = element.clientWidth;
const clientHeight = element.clientHeight;

const computedStyle = window.getComputedStyle(element);


**4. 浏览器窗口变化**


window.addEventListener('resize', () => {
  // 窗口大小变化会触发回流
});


#### 触发重绘的操作

**只改变外观，不影响布局:**


// 颜色
element.style.color = 'red';
element.style.backgroundColor = 'blue';

// 边框样式(不改变宽度)
element.style.borderStyle = 'dashed';

// 阴影
element.style.boxShadow = '0 0 10px red';

// 透明度(注意：opacity 可能触发合成层，性能更好)
element.style.opacity = 0.5;

// 可见性
element.style.visibility = 'hidden';  // 只重绘，不回流


#### 浏览器渲染流程

**完整流程:**


1. JavaScript 执行
   ↓
2. 样式计算(Style)
   ↓
3. 布局(Layout/Reflow) ← 回流在这里
   ↓
4. 绘制(Paint/Repaint) ← 重绘在这里
   ↓
5. 合成(Composite)


**回流:** 触发步骤 3、4、5
**重绘:** 触发步骤 4、5
**合成:** 只触发步骤 5（最快）

#### 性能优化策略

**1. 批量修改样式**


// ❌ 多次回流
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 一次回流(使用 class)
element.className = 'new-style';

// ✅ 一次回流(使用 cssText)
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';


**2. 批量修改 DOM**


// ❌ 多次回流
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  document.body.appendChild(div);  // 每次都回流
}

// ✅ 一次回流(使用 DocumentFragment)
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);  // 只回流一次


**3. 缓存布局信息**


// ❌ 每次都触发回流
for (let i = 0; i < 100; i++) {
  element.style.left = element.offsetLeft + 1 + 'px';  // 读写交替
}

// ✅ 缓存后再修改
const left = element.offsetLeft;  // 读一次
for (let i = 0; i < 100; i++) {
  element.style.left = left + i + 'px';  // 只写
}


**4. 使用 transform 代替 top/left**


// ❌ 触发回流
element.style.left = '100px';

// ✅ 不触发回流，使用合成层
element.style.transform = 'translateX(100px)';


**5. 使用 visibility 代替 display**


// ❌ 触发回流
element.style.display = 'none';

// ✅ 只触发重绘
element.style.visibility = 'hidden';


**6. 离线操作 DOM**


// ❌ 在线修改
element.style.width = '100px';
element.style.height = '100px';

// ✅ 离线修改(display: none 后修改)
element.style.display = 'none';
element.style.width = '100px';
element.style.height = '100px';
element.style.display = 'block';  // 只回流一次

// ✅ 使用 cloneNode
const clone = element.cloneNode(true);
clone.style.width = '100px';
clone.style.height = '100px';
element.parentNode.replaceChild(clone, element);


**7. 使用虚拟滚动**


// 对于长列表，只渲染可见区域
// 使用 react-window 或 react-virtualized


**8. 避免使用 table 布局**


<!-- ❌ table 布局：一个单元格变化，整个表格回流 -->
<table>...</table>

<!-- ✅ 使用 div + flex/grid -->
<div style="display: flex">...</div>


**9. 使用 will-change 提示浏览器**


.element {
  /* 提示浏览器该元素将要变化 */
  will-change: transform, opacity;
}

// 使用后记得移除
element.style.willChange = 'auto';


**10. 使用 requestAnimationFrame**


// ❌ 直接修改可能在错误时机
element.style.transform = 'translateX(100px)';

// ✅ 在浏览器重绘前修改
requestAnimationFrame(() => {
  element.style.transform = 'translateX(100px)';
});


#### 性能对比

| 操作类型 | 性能影响 | 示例 |
|---------|---------|------|
| **合成** | 最快 | `transform`, `opacity` |
| **重绘** | 较快 | `color`, `background-color` |
| **回流** | 最慢 | `width`, `height`, `top`, `left` |

**性能排序:** 合成 > 重绘 > 回流

#### 实际场景优化

**场景1: 动画**


/* ❌ 触发回流 */
@keyframes move {
  from { left: 0; }
  to { left: 100px; }
}

/* ✅ 使用 transform(合成) */
@keyframes move {
  from { transform: translateX(0); }
  to { transform: translateX(100px); }
}


**场景2: 显示/隐藏**


// ❌ 触发回流
element.style.display = 'none';

// ✅ 只触发重绘
element.style.visibility = 'hidden';

// ✅ 使用 opacity + pointer-events(合成)
element.style.opacity = '0';
element.style.pointerEvents = 'none';


**场景3: 列表渲染**


// ❌ 每次都回流
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  container.appendChild(div);  // 触发回流
});

// ✅ 使用 innerHTML(一次回流)
container.innerHTML = items.map(item => `<div>${item}</div>`).join('');

// ✅ 使用 DocumentFragment
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  fragment.appendChild(div);
});
container.appendChild(fragment);  // 只回流一次


#### 调试工具

**Chrome DevTools:**

1. **Performance 面板**
   - 录制性能
   - 查看 Layout(回流) 和 Paint(重绘) 事件

2. **Rendering 面板**
   - 开启 "Paint flashing"(绘制闪烁)
   - 开启 "Layout Shift Regions"(布局偏移区域)

3. **Layers 面板**
   - 查看合成层
   - 分析层的创建原因

#### 总结

**核心原则:**
1. **减少回流和重绘的次数**
2. **批量修改样式和 DOM**
3. **使用 transform 和 opacity 做动画**
4. **缓存布局信息**
5. **避免频繁读取会触发回流的属性**

**记忆口诀:**
- 改位置、改大小 → 回流
- 改颜色、改样式 → 重绘
- 用 transform、用 opacity → 合成(最快)

---

## 总结

**性能优化核心知识点:**
1. **动画性能**：CSS 动画 > JS 动画
2. **渲染性能**：合成 > 重绘 > 回流
3. **优化策略**：批量操作、缓存信息、使用 transform

**记忆技巧:**
- CSS 动画：GPU 加速，不占主线程
- 回流：改布局，慢
- 重绘：改样式，快
- 合成：transform/opacity，最快
