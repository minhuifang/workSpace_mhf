# 性能优化

> 前端性能优化：CSS vs JS 动画、回流与重绘、浏览器缓存等核心知识

## 目录

- [CSS vs JS 动画](#css-vs-js-动画)
- [回流与重绘优化](#回流与重绘优化)
- [浏览器缓存](#浏览器缓存)

---

## CSS vs JS 动画

### 通过 JS 实现一个动画和通过 CSS 实现一个动画，有什么区别，哪个性能更好？

#### CSS 动画 vs JS 动画

| 特性 | CSS 动画 | JS 动画 |
|------|----------|---------|
| **性能** | 更好（GPU 加速） | 较差（主线程） |
| **复杂度** | 简单动画 | 复杂动画 |
| **控制能力** | 有限 | 强大 |
| **兼容性** | 好 | 好 |
| **调试** | 较难 | 容易 |

#### 性能对比

**CSS 动画性能更好！**

**原因：**

1. **GPU 加速**
   - CSS 动画可以触发 GPU 加速
   - 使用 `transform` 和 `opacity` 不会触发重排（reflow）

2. **浏览器优化**
   - 浏览器会自动优化 CSS 动画
   - 可以在合成线程（Compositor Thread）执行

3. **主线程空闲**
   - CSS 动画不占用 JavaScript 主线程
   - JS 动画会阻塞其他 JS 执行

#### CSS 动画示例


/* 使用 transition */
.box {
  transition: transform 0.3s ease;
}

.box:hover {
  transform: translateX(100px);
}

/* 使用 animation */
@keyframes slide {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(100px);
  }
}

.box {
  animation: slide 1s ease infinite;
}


#### JS 动画示例


// 使用 requestAnimationFrame
function animate() {
  const box = document.querySelector('.box');
  let pos = 0;
  
  function step() {
    pos += 2;
    box.style.transform = `translateX(${pos}px)`;
    
    if (pos < 100) {
      requestAnimationFrame(step);
    }
  }
  
  requestAnimationFrame(step);
}

// 使用 Web Animations API
const box = document.querySelector('.box');
box.animate([
  { transform: 'translateX(0)' },
  { transform: 'translateX(100px)' }
], {
  duration: 1000,
  easing: 'ease-in-out'
});


#### 性能优化建议

**1. 优先使用 CSS 动画**


/* ✅ 好：使用 transform（不触发重排） */
.box {
  transform: translateX(100px);
}

/* ❌ 差：使用 left（触发重排） */
.box {
  left: 100px;
}


**2. 使用 will-change 提示浏览器**


.box {
  will-change: transform, opacity;
}


**3. 避免触发重排的属性**


// 触发重排的属性（慢）：
// width, height, top, left, margin, padding

// 不触发重排的属性（快）：
// transform, opacity


**4. 使用 requestAnimationFrame**


// ❌ 不要使用 setInterval
setInterval(() => {
  box.style.left = pos + 'px';
}, 16);

// ✅ 使用 requestAnimationFrame
function animate() {
  box.style.transform = `translateX(${pos}px)`;
  requestAnimationFrame(animate);
}


#### 使用场景选择

**使用 CSS 动画：**
- 简单的过渡效果
- 悬停效果
- 页面加载动画
- 性能要求高的场景

**使用 JS 动画：**
- 复杂的交互动画
- 需要精确控制的动画
- 需要根据用户输入动态调整
- 需要暂停/恢复/倒放

---

## 回流与重绘优化

### 回流(Reflow)和重绘(Repaint)的区别及场景

#### 概念区分

**回流(Reflow/重排):**
- 当元素的**几何属性**发生变化时
- 浏览器需要**重新计算元素的位置和大小**
- 会影响页面布局
- **性能开销大**

**重绘(Repaint):**
- 当元素的**样式**发生变化，但不影响布局时
- 浏览器只需要**重新绘制元素的外观**
- 不影响页面布局
- **性能开销较小**

#### 关系

**回流一定会引起重绘，但重绘不一定引起回流**


// 回流(改变布局) → 重新计算位置 → 重新绘制
element.style.width = '200px';  // 回流 + 重绘

// 重绘(只改变外观) → 重新绘制
element.style.color = 'red';    // 只重绘


#### 触发回流的操作

**1. 改变几何属性**


// 尺寸
element.style.width = '100px';
element.style.height = '100px';
element.style.padding = '10px';
element.style.margin = '10px';
element.style.border = '1px solid red';

// 位置
element.style.top = '10px';
element.style.left = '10px';

// 显示/隐藏
element.style.display = 'none';  // 回流
element.style.visibility = 'hidden';  // 不回流，只重绘


**2. 添加/删除 DOM 元素**


// 添加元素
parent.appendChild(newElement);

// 删除元素
parent.removeChild(element);

// 修改内容
element.innerHTML = 'new content';


**3. 获取某些属性**（会强制浏览器立即计算）


// 这些操作会触发浏览器立即回流
const width = element.offsetWidth;
const height = element.offsetHeight;
const top = element.offsetTop;
const left = element.offsetLeft;

const scrollTop = element.scrollTop;
const scrollHeight = element.scrollHeight;

const clientWidth = element.clientWidth;
const clientHeight = element.clientHeight;

const computedStyle = window.getComputedStyle(element);


**4. 浏览器窗口变化**


window.addEventListener('resize', () => {
  // 窗口大小变化会触发回流
});


#### 触发重绘的操作

**只改变外观，不影响布局:**


// 颜色
element.style.color = 'red';
element.style.backgroundColor = 'blue';

// 边框样式(不改变宽度)
element.style.borderStyle = 'dashed';

// 阴影
element.style.boxShadow = '0 0 10px red';

// 透明度(注意：opacity 可能触发合成层，性能更好)
element.style.opacity = 0.5;

// 可见性
element.style.visibility = 'hidden';  // 只重绘，不回流


#### 浏览器渲染流程

**完整流程:**


1. JavaScript 执行
   ↓
2. 样式计算(Style)
   ↓
3. 布局(Layout/Reflow) ← 回流在这里
   ↓
4. 绘制(Paint/Repaint) ← 重绘在这里
   ↓
5. 合成(Composite)


**回流:** 触发步骤 3、4、5
**重绘:** 触发步骤 4、5
**合成:** 只触发步骤 5（最快）

#### 性能优化策略

**1. 批量修改样式**


// ❌ 多次回流
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 一次回流(使用 class)
element.className = 'new-style';

// ✅ 一次回流(使用 cssText)
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';


**2. 批量修改 DOM**


// ❌ 多次回流
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  document.body.appendChild(div);  // 每次都回流
}

// ✅ 一次回流(使用 DocumentFragment)
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);  // 只回流一次


**3. 缓存布局信息**


// ❌ 每次都触发回流
for (let i = 0; i < 100; i++) {
  element.style.left = element.offsetLeft + 1 + 'px';  // 读写交替
}

// ✅ 缓存后再修改
const left = element.offsetLeft;  // 读一次
for (let i = 0; i < 100; i++) {
  element.style.left = left + i + 'px';  // 只写
}


**4. 使用 transform 代替 top/left**


// ❌ 触发回流
element.style.left = '100px';

// ✅ 不触发回流，使用合成层
element.style.transform = 'translateX(100px)';


**5. 使用 visibility 代替 display**


// ❌ 触发回流
element.style.display = 'none';

// ✅ 只触发重绘
element.style.visibility = 'hidden';


**6. 离线操作 DOM**


// ❌ 在线修改
element.style.width = '100px';
element.style.height = '100px';

// ✅ 离线修改(display: none 后修改)
element.style.display = 'none';
element.style.width = '100px';
element.style.height = '100px';
element.style.display = 'block';  // 只回流一次

// ✅ 使用 cloneNode
const clone = element.cloneNode(true);
clone.style.width = '100px';
clone.style.height = '100px';
element.parentNode.replaceChild(clone, element);


**7. 使用虚拟滚动**


// 对于长列表，只渲染可见区域
// 使用 react-window 或 react-virtualized


**8. 避免使用 table 布局**


<!-- ❌ table 布局：一个单元格变化，整个表格回流 -->
<table>...</table>

<!-- ✅ 使用 div + flex/grid -->
<div style="display: flex">...</div>


**9. 使用 will-change 提示浏览器**


.element {
  /* 提示浏览器该元素将要变化 */
  will-change: transform, opacity;
}

// 使用后记得移除
element.style.willChange = 'auto';


**10. 使用 requestAnimationFrame**


// ❌ 直接修改可能在错误时机
element.style.transform = 'translateX(100px)';

// ✅ 在浏览器重绘前修改
requestAnimationFrame(() => {
  element.style.transform = 'translateX(100px)';
});


#### 性能对比

| 操作类型 | 性能影响 | 示例 |
|---------|---------|------|
| **合成** | 最快 | `transform`, `opacity` |
| **重绘** | 较快 | `color`, `background-color` |
| **回流** | 最慢 | `width`, `height`, `top`, `left` |

**性能排序:** 合成 > 重绘 > 回流

#### 实际场景优化

**场景1: 动画**


/* ❌ 触发回流 */
@keyframes move {
  from { left: 0; }
  to { left: 100px; }
}

/* ✅ 使用 transform(合成) */
@keyframes move {
  from { transform: translateX(0); }
  to { transform: translateX(100px); }
}


**场景2: 显示/隐藏**


// ❌ 触发回流
element.style.display = 'none';

// ✅ 只触发重绘
element.style.visibility = 'hidden';

// ✅ 使用 opacity + pointer-events(合成)
element.style.opacity = '0';
element.style.pointerEvents = 'none';


**场景3: 列表渲染**


// ❌ 每次都回流
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  container.appendChild(div);  // 触发回流
});

// ✅ 使用 innerHTML(一次回流)
container.innerHTML = items.map(item => `<div>${item}</div>`).join('');

// ✅ 使用 DocumentFragment
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  fragment.appendChild(div);
});
container.appendChild(fragment);  // 只回流一次


#### 调试工具

**Chrome DevTools:**

1. **Performance 面板**
   - 录制性能
   - 查看 Layout(回流) 和 Paint(重绘) 事件

2. **Rendering 面板**
   - 开启 "Paint flashing"(绘制闪烁)
   - 开启 "Layout Shift Regions"(布局偏移区域)

3. **Layers 面板**
   - 查看合成层
   - 分析层的创建原因

#### 总结

**核心原则:**
1. **减少回流和重绘的次数**
2. **批量修改样式和 DOM**
3. **使用 transform 和 opacity 做动画**
4. **缓存布局信息**
5. **避免频繁读取会触发回流的属性**

**记忆口诀:**
- 改位置、改大小 → 回流
- 改颜色、改样式 → 重绘
- 用 transform、用 opacity → 合成(最快)

---

## 浏览器缓存

### 强缓存和协商缓存

#### 缓存机制概述

**浏览器缓存流程:**

```
1. 请求资源
   ↓
2. 检查强缓存
   ↓ 未过期          ↓ 过期
   直接使用缓存      检查协商缓存
                     ↓
                     向服务器验证
                     ↓
                     304(使用缓存) / 200(重新下载)
```

### 强缓存(Strong Cache)

**特点:**
- 不需要向服务器发送请求
- 直接从本地缓存读取
- 状态码: `200 (from disk cache)` 或 `200 (from memory cache)`

#### 1. Expires(HTTP/1.0)

```
# 服务器响应头
Expires: Wed, 21 Oct 2026 07:28:00 GMT
```

**缺点:**
- 使用绝对时间,依赖客户端时间
- 如果客户端时间不准确,会导致缓存失效

#### 2. Cache-Control(HTTP/1.1,优先级更高)

```
# 服务器响应头
Cache-Control: max-age=3600  # 缓存 1 小时
```

**常用指令:**

```
# 不使用缓存
Cache-Control: no-store

# 使用缓存前必须验证
Cache-Control: no-cache

# 缓存 1 年(常用于静态资源)
Cache-Control: max-age=31536000

# 只能被浏览器缓存,不能被代理服务器缓存
Cache-Control: private

# 可以被代理服务器缓存
Cache-Control: public

# 缓存过期后必须重新验证
Cache-Control: must-revalidate
```

### 协商缓存(Negotiation Cache)

**特点:**
- 需要向服务器发送请求验证
- 如果资源未修改,返回 304 Not Modified
- 如果资源已修改,返回 200 和新资源

#### 1. Last-Modified / If-Modified-Since

**工作流程:**

```
# 1. 首次请求,服务器返回
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
Content-Type: text/html

# 2. 再次请求,浏览器发送
GET /index.html HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT

# 3. 服务器响应
# 未修改:
HTTP/1.1 304 Not Modified

# 已修改:
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2025 08:00:00 GMT
```

**缺点:**
- 只能精确到秒级
- 如果文件在 1 秒内多次修改,无法识别
- 如果文件内容未变但修改时间变了,会重新下载

#### 2. ETag / If-None-Match(优先级更高)

**工作流程:**

```
# 1. 首次请求,服务器返回
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Content-Type: text/html

# 2. 再次请求,浏览器发送
GET /index.html HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# 3. 服务器响应
# 未修改:
HTTP/1.1 304 Not Modified

# 已修改:
HTTP/1.1 200 OK
ETag: "new-hash-value"
```

**优点:**
- 基于文件内容的哈希值
- 更精确,内容不变 ETag 就不变
- 不受时间影响

### 缓存策略对比

| 缓存类型 | 是否请求服务器 | 状态码 | 优先级 |
|---------|--------------|--------|--------|
| **强缓存** | 否 | 200 (from cache) | 高 |
| **协商缓存** | 是(验证) | 304 / 200 | 低 |

### 缓存优先级

```
Cache-Control > Expires
ETag > Last-Modified
```

### 实际应用场景

#### 1. 静态资源(HTML/CSS/JS/图片)

```javascript
// webpack 配置:文件名带 hash
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js'
  }
};

// 服务器配置:强缓存 1 年
app.use('/static', express.static('public', {
  maxAge: '1y',
  immutable: true
}));
```

**策略:**
- 文件名带 hash,内容变化时文件名变化
- 设置强缓存 1 年
- HTML 文件设置协商缓存或不缓存

#### 2. HTML 文件

```javascript
// 不使用强缓存,使用协商缓存
app.get('*.html', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache');
  res.sendFile(filePath);
});
```

**策略:**
- 不使用强缓存(no-cache)
- 使用 ETag 协商缓存
- 确保用户能及时获取最新版本

#### 3. API 接口

```javascript
// 不缓存
app.get('/api/*', (req, res) => {
  res.setHeader('Cache-Control', 'no-store');
  res.json(data);
});

// 短时间缓存
app.get('/api/config', (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=60'); // 缓存 1 分钟
  res.json(config);
});
```

**策略:**
- 动态数据:不缓存(no-store)
- 不常变化的配置:短时间强缓存

### 最佳实践

**根据资源类型设置缓存**

```javascript
const cacheConfig = {
  // 静态资源(带 hash):强缓存 1 年
  static: 'public, max-age=31536000, immutable',
  
  // HTML:协商缓存
  html: 'no-cache',
  
  // API:不缓存
  api: 'no-store',
  
  // 不常变化的资源:短时间缓存
  config: 'public, max-age=3600'
};
```

### 缓存优化总结

**核心原则:**
1. **静态资源(带 hash)**:强缓存 1 年
2. **HTML 文件**:协商缓存或不缓存
3. **API 接口**:不缓存或短时间缓存
4. **使用 ETag 优于 Last-Modified**
5. **使用 Cache-Control 优于 Expires**

**记忆口诀:**
- 强缓存:不问服务器,直接用
- 协商缓存:问服务器,304 用,200 下载
- 静态资源:强缓存 + hash
- HTML:协商缓存
- API:不缓存

---

## 总结

**性能优化核心知识点:**
1. **动画性能**：CSS 动画 > JS 动画
2. **渲染性能**：合成 > 重绘 > 回流
3. **缓存策略**：强缓存 > 协商缓存 > 不缓存
4. **优化策略**：批量操作、缓存信息、使用 transform

**记忆技巧:**
- CSS 动画：GPU 加速，不占主线程
- 回流：改布局，慢
- 重绘：改样式，快
- 合成：transform/opacity，最快
- 强缓存：直接用，最快
- 协商缓存：验证后用，较快



