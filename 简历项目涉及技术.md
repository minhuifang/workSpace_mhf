简历根据项目可能会问的问题

为什么选择 SSE (Server-Sent Events)
1. 单向数据流特性匹配场景
这是典型的单向推送场景,服务器需要持续向客户端推送 AI 生成的文本,而客户端只需要在提问时发送一次请求。SSE 天生就是为这种"服务器到客户端"的单向推送设计的。
AI 生成内容是逐字逐句产生的,使用 SSE 可以:
✅ 实时展示生成过程,提升用户体验
✅ 避免等待完整响应,降低感知延迟
✅ 支持超长文本生成(不受单次响应大小限制)
1. 相比轮询的优势
如果使用轮询:
❌ 需要不断发送请求查询状态,浪费带宽
❌ 延迟取决于轮询间隔(间隔短→资源浪费,间隔长→延迟高)
❌ 服务器需要维护会话状态供轮询查询
❌ 无法实现真正的"流式"效果
4. 相比 WebSocket 的优势
虽然 WebSocket 也能实现,但 SSE 更适合:

特性	   SSE	            WebSocket
协议	   基于 HTTP	     独立协议
连接建立	简单,自动重连	   需要握手,手动处理重连
防火墙/代理	兼容性好	       可能被阻止
实现复杂度	低	              高
双向通信	❌	             ✅
适用场景	服务器推送	       双向实时通信

总结
选择 SSE 是因为:

场景匹配:AI 流式输出是单向推送
用户体验:实时展示生成过程
实现简单:比 WebSocket 简单,比轮询高效
兼容性好:基于 HTTP,基础设施友好
这是一个技术选型与业务场景完美匹配的典型案例。如果未来需要双向实时通信(如多人协作、实时通知等),再考虑升级到 WebSocket。

umi3=》umi4升级
方面	Umi 3	Umi 4	影响
构建工具	Webpack 4/5	Webpack 5 + Vite（可选）	构建速度提升 10 倍+
React 版本	React 16/17	React 18	需要适配并发特性
路由	React Router 5	React Router 6	API 完全重写
Node 版本	Node 10+	Node 14+	需升级 Node
TypeScript	3.8+	4.0+	类型检查更严格


画像平台难点
需求复杂度高
🎯 需求的核心难点
1. 业务复杂度极高
这个需求包含5个核心步骤:

步骤1: 数据源配置(支持多数据源、维表关联、自定义字段、聚合配置、过滤条件)
步骤2: 工作流配置(集成第三方AI工作流组件)
步骤3: 表信息配置(支持Hive、Iceberg、Paimon、OceanBase等多种表类型)
步骤4: 溯源分析配置
步骤5: 调度任务配置和发布
每个步骤都有大量的子功能模块,整个流程涉及30+个子组件。

2. 数据管理复杂
多数据源管理: 最多支持5个数据源,每个数据源可以关联多个维表
字段联动: 数据源、维表、自定义字段、聚合字段之间存在复杂的联动关系
状态同步: 需要在Form表单、本地State、后端接口之间保持数据一致性

举个例子,当用户删除或替换一个维表时,需要:

// 清理所有引用该维表的配置
1. 清理聚合字段中使用该维表字段的配置
2. 清理分组字段中的引用
3. 清理自定义字段中包含该表别名的表达式
4. 清理字段输出配置中的引用
5. 更新过滤条件

3. 版本管理难度大
支持草稿版本、未验证版本、已验证版本、已发布版本
编辑时需要检查任务版本和表版本是否一致,不一致会导致表产出失败
实现了版本不匹配的可视化提示(带Warning图标的Steps)
4. 排他锁机制
为了防止多人同时编辑同一任务导致数据冲突,我实现了任务编辑排他锁:

5. 步骤间的状态管理
步骤1→步骤2: 需要进行数据预览校验,参数变化后必须重新预览
步骤2→步骤3: 需要调试成功才能进入,否则只能保存为"未验证版本"
步骤切换刷新策略:
前进到步骤3时强制刷新页面(避免数据不一致)
后退时不刷新(保持编辑状态)
使用isFromNextStepRef标记来源,控制刷新逻辑

💡 我的解决方案
1. 架构设计
我采用了分层组件设计:

CreateAndEdit (主容器)
├── TaskBasicInfo (基本信息)
├── DataSource (数据源配置)
│   ├── DimensionTableList (维表管理)
│   ├── DimensionColumns (自定义字段)
│   ├── TableFilter (过滤条件)
│   └── AggregateColumns (聚合配置)
├── FieldOutputsConfig (字段输出)
├── WorkFlowConfig (工作流)
├── TableConfig (表配置)
├── TraceConfig (溯源配置)
└── PubLishConfig (发布配置)

每个子组件职责单一,通过props传递数据和回调函数,降低耦合度。

2. 数据流管理
我使用Form + State双重管理:

Form: 管理用户输入,提供校验功能
State: 管理复杂的数据结构(如tableList、lookUps)
同步机制: 在关键节点同步Form和State
3. 字段联动的实现
我设计了columnKey机制:
这样在清理引用时,可以高效地找到所有相关配置。

4. 性能优化
防抖校验: 表别名校验使用validateDebounce: 300
按需刷新: 只在必要时刷新页面,避免频繁的网络请求
Promise.all并发: 获取多个表的字段信息时使用并发请求
5. 用户体验优化
数据预览强制校验: 步骤1必须预览成功才能进入步骤2
版本不匹配提示: 在Steps组件中显示Warning图标+Tooltip
未验证版本保存: 当调试未通过时,允许保存为未验证版本,避免数据丢失
加载状态管理: 使用Spin组件统一管理加载状态

收获:
复杂状态管理能力: 学会了在Form和State之间平衡,处理复杂的数据联动
架构设计能力: 通过组件拆分和数据流设计,降低了系统复杂度
性能优化意识: 使用防抖、并发请求、按需刷新等手段提升性能
用户体验思维: 从用户角度出发,设计了版本提示、数据预览校验等功能
代码质量意识: 通过TypeScript类型定义、详细注释、边界情况处理,提升代码可维护性

这个需求让我深刻体会到,复杂需求的关键不在于技术难度,而在于如何设计合理的架构、如何管理复杂的状态、如何处理各种边界情况。通过这个项目,我的工程能力得到了很大提升,也积累了处理复杂前端需求的经验。

Q1: 如果让你重新设计,你会怎么优化? A: 我会考虑引入状态管理库(如Zustand或Redux),将复杂的数据流从组件中抽离,降低组件复杂度。另外,可以将一些通用的逻辑(如字段清理、数据转换)抽取为工具函数或自定义Hooks,提高代码复用性。

Q2: 遇到最难的Bug是什么? A: 最难的是步骤切换时的数据一致性问题。一开始步骤3返回步骤2时,数据会丢失。后来我发现是因为页面刷新导致的,于是设计了isFromNextStepRef标记来区分前进和后退,只在必要时刷新页面,解决了这个问题。

Q3: 如何保证代码质量? A:

TypeScript类型定义: 定义了详细的Interface(Interface.ts文件)
代码注释: 关键逻辑都有注释说明
边界情况处理: 如空数组、undefined、重复数据等
单一职责: 每个组件和函数职责单一
Code Review: 与团队成员互相Review代码