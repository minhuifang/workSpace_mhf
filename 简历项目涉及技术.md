简历根据项目可能会问的问题

为什么选择 SSE (Server-Sent Events)
1. 单向数据流特性匹配场景
这是典型的单向推送场景,服务器需要持续向客户端推送 AI 生成的文本,而客户端只需要在提问时发送一次请求。SSE 天生就是为这种"服务器到客户端"的单向推送设计的。
AI 生成内容是逐字逐句产生的,使用 SSE 可以:
✅ 实时展示生成过程,提升用户体验
✅ 避免等待完整响应,降低感知延迟
✅ 支持超长文本生成(不受单次响应大小限制)
1. 相比轮询的优势
如果使用轮询:
❌ 需要不断发送请求查询状态,浪费带宽
❌ 延迟取决于轮询间隔(间隔短→资源浪费,间隔长→延迟高)
❌ 服务器需要维护会话状态供轮询查询
❌ 无法实现真正的"流式"效果
4. 相比 WebSocket 的优势
虽然 WebSocket 也能实现,但 SSE 更适合:

特性	   SSE	            WebSocket
协议	   基于 HTTP	     独立协议
连接建立	简单,自动重连	   需要握手,手动处理重连
防火墙/代理	兼容性好	       可能被阻止
实现复杂度	低	              高
双向通信	❌	             ✅
适用场景	服务器推送	       双向实时通信

总结
选择 SSE 是因为:

场景匹配:AI 流式输出是单向推送
用户体验:实时展示生成过程
实现简单:比 WebSocket 简单,比轮询高效
兼容性好:基于 HTTP,基础设施友好
这是一个技术选型与业务场景完美匹配的典型案例。如果未来需要双向实时通信(如多人协作、实时通知等),再考虑升级到 WebSocket。

. 完整的断点重连流程
用户发送消息 → 创建新的 AbortController
建立 SSE 连接 → fetchEventSource 开始接收数据流
接收数据 → handleMessage 处理每条消息，清除超时定时器
如果出错/超时：
调用 promptError 显示错误信息
调用 stopCurrentRequest 中断请求
用户可以点击"重新生成"按钮重新发送
如果用户主动停止：
点击停止按钮 → 调用 stopCurrentRequest
AbortController.abort() 中断连接
重新连接：
用户点击"重新生成" → 重新调用 handleSendMessage
携带相同的 threadId 保持会话连续性

打字机功能
✅ 方案1（字符队列 + 定时器）实现完成！
📋 实现内容
我已经成功为你的 AI 助手添加了打字机效果，主要修改包括：

1️⃣ 添加的状态和引用（index.tsx:100-106）
// 字符队列：存储待显示的字符
const charQueueRef = useRef<string[]>([])

// 打字机定时器
const typewriterTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)
2️⃣ 核心函数（index.tsx:279-345）
startTypewriter() - 启动打字机
每 50ms 从队列取出 1 个字符显示
自动处理队列为空的情况
避免重复启动定时器
stopTypewriter() - 停止打字机
清除定时器，停止字符显示
flushTypewriter() - 立即显示所有剩余字符
用于"停止"按钮、完成、错误等场景
将队列中所有字符一次性显示
3️⃣ 修改的逻辑
handleMessage 函数（index.tsx:409-431）
// 原来：直接累加显示
fullText: lastMessage.fullText + fullText

// 现在：放入字符队列
const chars = Array.from(fullText) // 正确处理 emoji
charQueueRef.current.push(...chars)
startTypewriter()
stopCurrentRequest 函数（index.tsx:203-204）
停止时立即显示所有剩余字符
handleClose 函数（index.tsx:449-450）
SSE 关闭时立即显示所有剩余字符
newChat 函数（index.tsx:138-139）
新会话时清空字符队列
handleSendMessage 函数（index.tsx:260-261）
发送新消息时清空字符队列
4️⃣ 组件清理（index.tsx:536-542）
useEffect(() => {
  return () => {
    stopTypewriter()
    charQueueRef.current = []
  }
}, [])
🎯 效果说明
打字速度
每个字符间隔：50ms（可在 index.tsx:310 调整）
约等于每秒显示 20 个字符
用户体验
正常流式输出：逐字显示，流畅的打字机效果
点击"停止"按钮：立即显示所有剩余内容
SSE 完成：自动显示所有剩余内容
发送新消息：清空上一次的队列
新会话：重置所有状态
技术亮点
✅ 使用 Array.from() 正确处理 Unicode 字符（emoji、中文等）
✅ 队列机制避免丢失字符
✅ 定时器自动管理，无内存泄漏
✅ 完善的边界情况处理
✅ 兼容原有的 Markdown 渲染

🔧 可调整参数
打字速度（index.tsx:310）
typewriterTimerRef.current = setTimeout(typeNextChar, 50) // 👈 修改这里

// 建议值：
// 30ms = 快速（每秒 33 字）
// 50ms = 中速（每秒 20 字）推荐
// 80ms = 慢速（每秒 12 字）
动态速度（可选优化）
如果想根据队列长度动态调整速度，可以修改为：

const delay = charQueueRef.current.length > 100 ? 30 : 50 // 队列长时加速
typewriterTimerRef.current = setTimeout(typeNextChar, delay)


umi3=》umi4升级
方面	Umi 3	Umi 4	影响
构建工具	Webpack 4/5	Webpack 5 + Vite（可选）	构建速度提升 10 倍+
React 版本	React 16/17	React 18	需要适配并发特性
路由	React Router 5	React Router 6	API 完全重写
Node 版本	Node 10+	Node 14+	需升级 Node
TypeScript	3.8+	4.0+	类型检查更严格


画像平台难点
需求复杂度高
🎯 需求的核心难点
1. 业务复杂度极高
这个需求包含5个核心步骤:

步骤1: 数据源配置(支持多数据源、维表关联、自定义字段、聚合配置、过滤条件)
步骤2: 工作流配置(集成第三方AI工作流组件)
步骤3: 表信息配置(支持Hive、Iceberg、Paimon、OceanBase等多种表类型)
步骤4: 溯源分析配置
步骤5: 调度任务配置和发布
每个步骤都有大量的子功能模块,整个流程涉及30+个子组件。

2. 数据管理复杂
多数据源管理: 最多支持5个数据源,每个数据源可以关联多个维表
字段联动: 数据源、维表、自定义字段、聚合字段之间存在复杂的联动关系
状态同步: 需要在Form表单、本地State、后端接口之间保持数据一致性

举个例子,当用户删除或替换一个维表时,需要:

// 清理所有引用该维表的配置
1. 清理聚合字段中使用该维表字段的配置
2. 清理分组字段中的引用
3. 清理自定义字段中包含该表别名的表达式
4. 清理字段输出配置中的引用
5. 更新过滤条件

3. 版本管理难度大
支持草稿版本、未验证版本、已验证版本、已发布版本
编辑时需要检查任务版本和表版本是否一致,不一致会导致表产出失败
实现了版本不匹配的可视化提示(带Warning图标的Steps)
4. 排他锁机制
为了防止多人同时编辑同一任务导致数据冲突,我实现了任务编辑排他锁:

5. 步骤间的状态管理
步骤1→步骤2: 需要进行数据预览校验,参数变化后必须重新预览
步骤2→步骤3: 需要调试成功才能进入,否则只能保存为"未验证版本"
步骤切换刷新策略:
前进到步骤3时强制刷新页面(避免数据不一致)
后退时不刷新(保持编辑状态)
使用isFromNextStepRef标记来源,控制刷新逻辑

💡 我的解决方案
1. 架构设计
我采用了分层组件设计:

CreateAndEdit (主容器)
├── TaskBasicInfo (基本信息)
├── DataSource (数据源配置)
│   ├── DimensionTableList (维表管理)
│   ├── DimensionColumns (自定义字段)
│   ├── TableFilter (过滤条件)
│   └── AggregateColumns (聚合配置)
├── FieldOutputsConfig (字段输出)
├── WorkFlowConfig (工作流)
├── TableConfig (表配置)
├── TraceConfig (溯源配置)
└── PubLishConfig (发布配置)

每个子组件职责单一,通过props传递数据和回调函数,降低耦合度。

2. 数据流管理
我使用Form + State双重管理:

Form: 管理用户输入,提供校验功能
State: 管理复杂的数据结构(如tableList、lookUps)
同步机制: 在关键节点同步Form和State
3. 字段联动的实现
我设计了columnKey机制:
这样在清理引用时,可以高效地找到所有相关配置。

4. 性能优化
防抖校验: 表别名校验使用validateDebounce: 300
按需刷新: 只在必要时刷新页面,避免频繁的网络请求
Promise.all并发: 获取多个表的字段信息时使用并发请求
5. 用户体验优化
数据预览强制校验: 步骤1必须预览成功才能进入步骤2
版本不匹配提示: 在Steps组件中显示Warning图标+Tooltip
未验证版本保存: 当调试未通过时,允许保存为未验证版本,避免数据丢失
加载状态管理: 使用Spin组件统一管理加载状态

收获:
复杂状态管理能力: 学会了在Form和State之间平衡,处理复杂的数据联动
架构设计能力: 通过组件拆分和数据流设计,降低了系统复杂度
性能优化意识: 使用防抖、并发请求、按需刷新等手段提升性能
用户体验思维: 从用户角度出发,设计了版本提示、数据预览校验等功能
代码质量意识: 通过TypeScript类型定义、详细注释、边界情况处理,提升代码可维护性

这个需求让我深刻体会到,复杂需求的关键不在于技术难度,而在于如何设计合理的架构、如何管理复杂的状态、如何处理各种边界情况。通过这个项目,我的工程能力得到了很大提升,也积累了处理复杂前端需求的经验。

Q1: 如果让你重新设计,你会怎么优化? A: 我会考虑引入状态管理库(如Zustand或Redux),将复杂的数据流从组件中抽离,降低组件复杂度。另外,可以将一些通用的逻辑(如字段清理、数据转换)抽取为工具函数或自定义Hooks,提高代码复用性。

Q2: 遇到最难的Bug是什么? A: 最难的是步骤切换时的数据一致性问题。一开始步骤3返回步骤2时,数据会丢失。后来我发现是因为页面刷新导致的,于是设计了isFromNextStepRef标记来区分前进和后退,只在必要时刷新页面,解决了这个问题。

Q3: 如何保证代码质量? A:

TypeScript类型定义: 定义了详细的Interface(Interface.ts文件)
代码注释: 关键逻辑都有注释说明
边界情况处理: 如空数组、undefined、重复数据等
单一职责: 每个组件和函数职责单一
Code Review: 与团队成员互相Review代码