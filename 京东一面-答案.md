# 京东一面问题答案（精简版）

## 1. 除了 CSS Modules，还可以用什么做样式隔离？

### 样式隔离方案

1. **CSS-in-JS**（styled-components、emotion）
   
   const Button = styled.button`
     background: blue;
   `;
   

2. **Scoped CSS**（Vue 的 scoped）
   
   <style scoped>
   .button { color: red; }
   </style>
   

3. **BEM 命名规范**
   
   .button {}
   .button__icon {}
   .button--primary {}
   

4. **Shadow DOM**（Web Components）

5. **Tailwind CSS**（原子化 CSS）
   
   <button className="bg-blue-500 text-white px-4 py-2">
   

### Service Worker 的作用

- **离线缓存**：让网页离线可用（PWA）
- **拦截请求**：可以拦截和修改网络请求
- **推送通知**：接收服务器推送消息

---

## 2. ES6 有哪些热门语法？

1. **let/const**：块级作用域
2. **箭头函数**：`const add = (a, b) => a + b`
3. **模板字符串**：`` `Hello ${name}` ``
4. **解构赋值**：`const { name, age } = obj`
5. **扩展运算符**：`[...arr]`、`{...obj}`
6. **Promise/async/await**：异步编程
7. **Class**：类语法
8. **模块化**：`import/export`
9. **Set/Map**：新数据结构
10. **可选链**：`obj?.a?.b`

---

## 3. 同步任务、异步任务的机制

### 事件循环（Event Loop）

**执行顺序：**

1. 执行同步代码
2. 执行微任务（Promise.then）
3. 执行宏任务（setTimeout）
4. 重复 2-3


**任务分类：**
- **宏任务**：setTimeout、setInterval、I/O
- **微任务**：Promise.then、async/await

**示例：**

console.log('1');           // 同步

setTimeout(() => {
  console.log('2');         // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3');         // 微任务
});

console.log('4');           // 同步

// 输出：1 → 4 → 3 → 2


---

## 4. 数组有哪些方法？map 和 forEach 的区别

### 常用数组方法

**改变原数组：**
- `push/pop`：末尾增删
- `unshift/shift`：开头增删
- `splice`：删除/插入/替换
- `sort/reverse`：排序/反转

**不改变原数组：**
- `slice`：截取
- `concat`：合并
- `map`：映射
- `filter`：过滤
- `reduce`：累加
- `find/findIndex`：查找

### map vs forEach

| 特性 | forEach | map |
|------|---------|-----|
| **返回值** | undefined | 新数组 |
| **链式调用** | 不支持 | 支持 |
| **使用场景** | 遍历、执行副作用 | 转换数组 |

**示例：**

const arr = [1, 2, 3];

// forEach：无返回值
arr.forEach(item => console.log(item));

// map：返回新数组
const doubled = arr.map(item => item * 2); // [2, 4, 6]


---

## 5. React Hooks 有哪些？useState 和 useRef 的区别，useEffect 的作用

### 常用 Hooks

- `useState`：状态管理
- `useEffect`：副作用处理
- `useContext`：上下文
- `useRef`：引用对象
- `useMemo`：缓存计算结果
- `useCallback`：缓存函数

### useState vs useRef

| 特性 | useState | useRef |
|------|----------|--------|
| **触发渲染** | 是 | 否 |
| **使用场景** | 需要显示的状态 | DOM 引用、定时器 ID |
| **更新方式** | `setState` | 直接修改 `.current` |

ref的特性：

useRef返回的对象在组件整个生命周期中保持同一引用
修改ref.current不会触发重渲染
闭包中访问ref.current总是获取最新值
**示例：**

// useState：更新会重新渲染
const [count, setCount] = useState(0);
setCount(count + 1); // 触发渲染

// useRef：更新不会重新渲染
const countRef = useRef(0);
countRef.current += 1; // 不触发渲染


### useEffect 的作用

**处理副作用：**
- 数据获取（API 调用）
- 订阅/取消订阅
- 定时器
- DOM 操作

**三种用法：**

// 1. 每次渲染都执行
useEffect(() => {});

// 2. 只执行一次（挂载时）
useEffect(() => {}, []);

// 3. 依赖变化时执行
useEffect(() => {}, [count]);


---

## 6. 组件卸载时关闭定时器怎么做？

### 使用 useEffect 的清理函数


function Timer() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 启动定时器
    const timer = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
    
    // 返回清理函数（组件卸载时执行）
    return () => {
      clearInterval(timer);
    };
  }, []); // 空数组：只在挂载和卸载时执行
  
  return <div>{count}</div>;
}


**关键点：**
- `useEffect` 返回一个函数
- 这个函数在组件卸载时执行
- 第二个参数传空数组 `[]`，表示只在挂载和卸载时执行

**其他清理场景：**

useEffect(() => {
  // 事件监听
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);

useEffect(() => {
  // WebSocket
  const ws = new WebSocket('ws://...');
  return () => ws.close();
}, []);


---

## 7. useCallback 和 useMemo 的区别

### 对比

| 特性 | useCallback | useMemo |
|------|-------------|---------|
| **缓存内容** | 函数 | 计算结果（值） |
| **返回值** | 函数本身 | 函数执行结果 |
| **使用场景** | 避免子组件重复渲染 | 避免重复计算 |

### 示例

```javascript
// useCallback：缓存函数
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);

// useMemo：缓存计算结果
const expensiveValue = useMemo(() => {
  return count * 2; // 返回计算结果
}, [count]);
```

### 记忆技巧
- `useCallback(fn, deps)` = `useMemo(() => fn, deps)`
- useCallback 返回函数，useMemo 返回值

---

## 8. Git 使用方法

### 撤销提交

**1. 撤销最近一次提交（保留修改）**
```bash
git reset --soft HEAD~1
# 代码还在，只是撤销了 commit
```

**2. 撤销最近一次提交（不保留修改）**
```bash
git reset --hard HEAD~1
# 代码和 commit 都撤销
```

**3. 修改最近一次提交**
```bash
git commit --amend
# 修改最后一次提交的内容或信息
```

**4. 撤销已 push 的提交**
```bash
git revert <commit-id>
# 创建一个新提交来撤销之前的提交
```

### 解决代码冲突

**步骤：**

1. **拉取最新代码**
   ```bash
   git pull origin main
   # 或
   git fetch origin
   git merge origin/main
   ```

2. **查看冲突文件**
   ```bash
   git status
   # 显示有冲突的文件
   ```

3. **手动解决冲突**
   ```javascript
   // 冲突文件会显示：
   <<<<<<< HEAD
   你的代码
   =======
   别人的代码
   >>>>>>> branch-name
   
   // 手动选择保留哪部分，删除冲突标记
   ```

4. **标记为已解决**
   ```bash
   git add <冲突文件>
   ```

5. **提交合并**
   ```bash
   git commit -m "解决冲突"
   git push
   ```

**预防冲突：**
- 提交前先 `git pull`
- 经常同步主分支
- 小步提交，避免大改动

---

## 9. Webpack 调优和 Loader

### Webpack 性能优化

**1. 构建速度优化**
```javascript
module.exports = {
  // 缩小文件搜索范围
  resolve: {
    modules: ['node_modules'],
    extensions: ['.js', '.jsx']
  },
  
  // 使用缓存
  cache: {
    type: 'filesystem'
  },
  
  // 多线程打包
  use: {
    loader: 'thread-loader'
  }
}
```

**2. 打包体积优化**
```javascript
module.exports = {
  // 代码分割
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  },
  
  // 压缩
  minimizer: [
    new TerserPlugin(),
    new CssMinimizerPlugin()
  ]
}
```

**3. 其他优化**
- Tree Shaking：去除未使用代码
- 懒加载：`import()` 动态导入
- CDN：外部库使用 CDN
- 图片压缩：使用 image-webpack-loader

### 常用 Loader

**1. 样式相关**
```javascript
{
  test: /\.css$/,
  use: ['style-loader', 'css-loader']
}

{
  test: /\.scss$/,
  use: ['style-loader', 'css-loader', 'sass-loader']
}
```

**2. 文件相关**
```javascript
{
  test: /\.(png|jpg|gif)$/,
  type: 'asset/resource'
}

{
  test: /\.(woff|woff2|eot|ttf)$/,
  type: 'asset/resource'
}
```

**3. JavaScript 相关**
```javascript
{
  test: /\.js$/,
  use: 'babel-loader',
  exclude: /node_modules/
}
```

**Loader 执行顺序：**
- 从右到左，从下到上
- 例如：`['style-loader', 'css-loader']`
  - 先执行 css-loader
  - 再执行 style-loader

---

## 面试回答技巧

1. **先说核心概念**，再举例子
2. **对比优缺点**，展示思考深度
3. **结合实际项目**经验
4. **简洁明了**，不要过度展开



