# 京东一面问题答案（精简版）

## 1. 除了 CSS Modules，还可以用什么做样式隔离？

### 样式隔离方案

1. **CSS-in-JS**（styled-components、emotion）
   
   const Button = styled.button`
     background: blue;
   `;
   

2. **Scoped CSS**（Vue 的 scoped）
   
   <style scoped>
   .button { color: red; }
   </style>
   

3. **BEM 命名规范**
   
   .button {}
   .button__icon {}
   .button--primary {}
   

4. **Shadow DOM**（Web Components）

5. **Tailwind CSS**（原子化 CSS）
   
   <button className="bg-blue-500 text-white px-4 py-2">
   

### Service Worker 的作用

- **离线缓存**：让网页离线可用（PWA）
- **拦截请求**：可以拦截和修改网络请求
- **推送通知**：接收服务器推送消息

---

## 2. ES6 有哪些热门语法？

1. **let/const**：块级作用域
2. **箭头函数**：`const add = (a, b) => a + b`
3. **模板字符串**：`` `Hello ${name}` ``
4. **解构赋值**：`const { name, age } = obj`
5. **扩展运算符**：`[...arr]`、`{...obj}`
6. **Promise/async/await**：异步编程
7. **Class**：类语法
8. **模块化**：`import/export`
9. **Set/Map**：新数据结构
10. **可选链**：`obj?.a?.b`

---

## 3. 同步任务、异步任务的机制

### 事件循环（Event Loop）

**执行顺序：**

1. 执行同步代码
2. 执行微任务（Promise.then）
3. 执行宏任务（setTimeout）
4. 重复 2-3


**任务分类：**
- **宏任务**：setTimeout、setInterval、I/O
- **微任务**：Promise.then、async/await

**示例：**

console.log('1');           // 同步

setTimeout(() => {
  console.log('2');         // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3');         // 微任务
});

console.log('4');           // 同步

// 输出：1 → 4 → 3 → 2


---

## 4. 数组有哪些方法？map 和 forEach 的区别

### 常用数组方法

**改变原数组：**
- `push/pop`：末尾增删
- `unshift/shift`：开头增删
- `splice`：删除/插入/替换
- `sort/reverse`：排序/反转

**不改变原数组：**
- `slice`：截取
- `concat`：合并
- `map`：映射
- `filter`：过滤
- `reduce`：累加
- `find/findIndex`：查找

### map vs forEach

| 特性 | forEach | map |
|------|---------|-----|
| **返回值** | undefined | 新数组 |
| **链式调用** | 不支持 | 支持 |
| **使用场景** | 遍历、执行副作用 | 转换数组 |

**示例：**

const arr = [1, 2, 3];

// forEach：无返回值
arr.forEach(item => console.log(item));

// map：返回新数组
const doubled = arr.map(item => item * 2); // [2, 4, 6]


---

## 5. React Hooks 有哪些？useState 和 useRef 的区别，useEffect 的作用

### 常用 Hooks

- `useState`：状态管理
- `useEffect`：副作用处理
- `useContext`：上下文
- `useRef`：引用对象
- `useMemo`：缓存计算结果
- `useCallback`：缓存函数

### useState vs useRef

| 特性 | useState | useRef |
|------|----------|--------|
| **触发渲染** | 是 | 否 |
| **使用场景** | 需要显示的状态 | DOM 引用、定时器 ID |
| **更新方式** | `setState` | 直接修改 `.current` |

**示例：**

// useState：更新会重新渲染
const [count, setCount] = useState(0);
setCount(count + 1); // 触发渲染

// useRef：更新不会重新渲染
const countRef = useRef(0);
countRef.current += 1; // 不触发渲染


### useEffect 的作用

**处理副作用：**
- 数据获取（API 调用）
- 订阅/取消订阅
- 定时器
- DOM 操作

**三种用法：**

// 1. 每次渲染都执行
useEffect(() => {});

// 2. 只执行一次（挂载时）
useEffect(() => {}, []);

// 3. 依赖变化时执行
useEffect(() => {}, [count]);


---

## 6. 组件卸载时关闭定时器怎么做？

### 使用 useEffect 的清理函数


function Timer() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 启动定时器
    const timer = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
    
    // 返回清理函数（组件卸载时执行）
    return () => {
      clearInterval(timer);
    };
  }, []); // 空数组：只在挂载和卸载时执行
  
  return <div>{count}</div>;
}


**关键点：**
- `useEffect` 返回一个函数
- 这个函数在组件卸载时执行
- 第二个参数传空数组 `[]`，表示只在挂载和卸载时执行

**其他清理场景：**

useEffect(() => {
  // 事件监听
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);

useEffect(() => {
  // WebSocket
  const ws = new WebSocket('ws://...');
  return () => ws.close();
}, []);


---

## 面试回答技巧

1. **先说核心概念**，再举例子
2. **对比优缺点**，展示思考深度
3. **结合实际项目**经验
4. **简洁明了**，不要过度展开

